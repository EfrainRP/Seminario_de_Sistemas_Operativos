__pycache__

    def inputProcess():
        def validationID(dictProcess):
            id = input("Introduzca la ID: ")
            while not re.match("^[1-9]+\d*$", id) or id in dictProcess:#Verificate if the ID is repeated and use expresion regular for numbres from 1 to infinity
                id = input("\tID INVALIDA\t\tIntroduzca nueva ID: ")

            return id

        def opValidator(opN,N):
            while not re.match(r'^[+-]?\d+$', opN):  #We use a expresion regular to validate the string for real numbers
                opN = input(f'\tCifra invalida\t\tIntroduzca NUEVAMENTE la #{N} cifra: ')
            return opN

        def operation():
            op1 = input("\tOPERACION\nIntroduzca la primera cifra: ")
            op1 = int(opValidator(op1,1))
            op2 = input("Introduzca la segunda cifra: ")
            op2 = int(opValidator(op2,2))

            op = input("Introduzca la operacion a realizar: ")
            while not re.match(r'^[+\-*/%]$', op): #We use a expresion regular to validate the string for operators
                    op = input("\tIntroduzca NUEVAMENTE la operacion a realizar: ")

            if op == "+":
                result = op1+op2
                return result,f'{op1} + {op2}'
            elif op == "-":
                result = op1-op2
                return result,f'{op1} - {op2}'
            elif op == "*":
                result = op1*op2
                return result,f'{op1} * {op2}'
            elif op == "/": # / (division)
                ''' try: #Exception of 0 as divisor
                    result = op1/op2
                except ZeroDivisionError:
                    print("No se puede dividir entre cero :(\n\tIngrese nuevos valores")
                '''
                while op2 == 0:
                    op2 = input("No se puede dividir entre cero :(\n\tIntroduzca NUEVAMENTE la segunda cifra: ")
                    op2 = int(opValidator(op2,2))
                result = op1/op2
                return result,f'{op1} / {op2}'
            elif op =="%":
                ''' try: #Exception of 0 as divisor
                    result = op1%op2
                except ZeroDivisionError:
                    print("No se puede dividir entre cero :(\n\tIngrese nuevos valores")
                '''
                while op2 == 0:
                    op2 = input("No se puede dividir entre cero :(\n\tIntroduzca NUEVAMENTE la segunda cifra: ")
                    op2 = int(opValidator(op2,2))
                result = op1%op2
                return result,f'{op1} % {op2}'

        def inputProcess(dictProcess,actual_batch):
                nombre = input("Introduzca un nombre: ")
                while not re.match("^[a-zA-Z]+\s?[a-zA-Z]*$", nombre): #We use a expresion regular to validate the string
                    nombre = input("\tIntroduzca NUEVAMENTE un nombre: ")

                id = validationID(dictProcess)
                result,opString = operation()
                time = input("Introduzca el tiempo aproximado: ")
                while not re.match("^[1-9]+\d*$", time):  #We use a expresion regular to validate the string for time
                    time = input("\tIntroduzca NUEVAMENTE el tiempo aproximado: ")

                dictProcess[id] = (nombre,opString,result,int(time),actual_batch)


def clicked_button1(self):
        ui = Ui_Data()
        process = self.process.value()
        if process > 0:
            print(process)
            ui.setupUi(self.windowData,process)
            self.windowData.show()

self.windowData = QMainWindow()
self.enterInput1.clicked.connect(self.clicked_button1)

self.enterInput1.clicked.connect(self.clicked_button1)